# 1 线程函数的入口及写法

线程通过 thread 函数创建，线程的逻辑和执行时间等细微操作可以通过子线程中设置时间处理函数来实现。线程调用了 join 方法，这是必须有的步骤，为的是主线程等待子线程退出后才可以退出，否则退出主线程会报错。除了用 join 方法阻塞等待子线程执行，也可以使用 detach 方法，子线程和主线程分离。

线程入口函数可以有以下几种：（1）全局函数，线程参数在线程创建的时候会进行参数复制，即线程使用的是参数的副本，因此如果参数在栈中已经被释放了，线程执行依旧不会报错。

线程传递引用要有 ref 修饰引用，传递指针的示例显示 detach 会出错，join 则不会出错。需要根据自己的开发环境编译调试程序，确定是否会出错。

随后的代码演示了用 lambda 函数作为线程入口，以及设计线程类，并且用成员函数作为线程入口，请参考相应代码。

# 2 线程和锁

锁是线程同步的手段，即多个线程如何访问竞态资源的工具。需要明确两个概念，1是竞争状态：多线程同时读写共享数据；2是临界区：读写共享数据的代码片段。

线程具有阻塞状态，主动进入阻塞状态需要调用 sleep函数，不占用cpu。单片机上没有这个函数，用 while 循环实现阻塞。

避免竞争状态策略，对临界区进行保护，同时只能由一个线程进入临界区。使用C++11提供的mutex。

try_lock（）这种方式，即便没有获取锁，也可以执行一些操作，比如刷新页面等。

互斥锁这里有个坑，就是只有一个线程能拿到锁，其它线程都没有锁。

```c++
for(;;) {
    mutex.lock();
    ...
    mutex.unlock();
}
```
这种代码写法，操作系统并没有将资源释放掉。正确的做法是 unlock() 后给操作系统留好一定时间。

超时锁应用 timed_mutex（避免长时间死锁），递归锁，防止像一般锁那样，给锁加锁报错。递归锁加锁会把原有锁计数+1.

共享锁 shared_mutex,就是操作系统概念中的读写锁，即读不加锁，写加锁，其它线程阻塞等待写操作完成。避免资源被多人写会出现的错误。

以上几种线程同步的手段，需要参考具体的代码掌握。我在 Linux-learning-note 中会备份，因为代码有版权，暂不公开，开发环境是 vs2019.


